zero.pvalue.adj=p.adjust(pvals.z, method="BH"),
DDcategory=cats.all,
Clusters.combined=comps.all.ALL,
Clusters.c1=comps.c1.ALL,
Clusters.c2=comps.c2.ALL)
rownames(Genes) <- rownames(SCdat)
# place these results objects in the appropriately named assays()
# slots of the SummarizedExperiment object
metadata(SCdat)[["Genes"]] <- Genes
metadata(SCdat)[["Zhat.combined"]] <- MAP
metadata(SCdat)[["Zhat.c1"]] <- MAP1
metadata(SCdat)[["Zhat.c2"]] <- MAP2
head(results(SCdat))
ls()
sessionInfo()
library(scDD)
# read in dataset from Sara (object is named eset.scdd)
load("~/Desktop/scRNAseq/CODE/eset_forKeegan.rda")
# convert eset.scdd to SummarizedExperiment object compatible with new version
library(SummarizedExperiment )
cond <- data.frame(as.numeric(phenoData(eset.scdd)@data$condition))
rownames(cond) <- colnames(exprs(eset.scdd))
colnames(cond) <- "condition"
sumExp <- SummarizedExperiment(assays=list("NormCounts"=exprs(eset.scdd)),
colData=cond)
rm(eset.scdd)
# run scDD without permutations (KS version)
prior_param=list(alpha=0.01, mu0=0, s0=0.01, a0=0.01, b0=0.01)
sumExp <- scDD(sumExp, prior_param=prior_param,
permutations=0, testZeroes=TRUE)
head(results(eset.scdd))
head(results(sumExp))
table(results(sumExp)$DDcategory)
sum(is.na(results(sumExp)))
head(results(sumExp))
table(results(sumExp)$DDcategory)
sum(is.na(results(sumExp)$DDcategory))
sum(is.na(results(sumExp)$nonzero.pvalue))
?results
results(sumExp, type="Zhat.combined")[1:5,1:5]
table(results(sumExp, type="Zhat.combined")[2,])
table(results(sumExp, type="Zhat.combined")[1,])
table(results(sumExp, type="Zhat.combined")[3,])
table(results(sumExp, type="Zhat.combined")[4,])
table(results(sumExp, type="Zhat.combined")[5,])
table(results(sumExp, type="Zhat.combined")[6,])
table(results(sumExp, type="Zhat.combined")[7,])
table(results(sumExp, type="Zhag.combined")[tofit,])
table(results(sumExp, type="Zhat.combined")[tofit,])
table(results(sumExp, type="Zhag.c1")[tofit,])
table(results(sumExp, type="Zhat.c1")[tofit,])
table(results(sumExp, type="Zhat.c1")[1,])
table(results(sumExp, type="Zhat.c1")[2,])
table(results(sumExp, type="Zhat.c1")[3,])
sessionInfo()
scDD:::mclust.restricted
library(scDD)
scDD:::mclust.restricted
scDD:::mclustRestricted
library(scDD)
# read in dataset from Sara (object is named eset.scdd)
load("~/Desktop/scRNAseq/CODE/eset_forKeegan.rda")
# convert eset.scdd to SummarizedExperiment object compatible with new version
library(SummarizedExperiment )
cond <- data.frame(as.numeric(phenoData(eset.scdd)@data$condition))
rownames(cond) <- colnames(exprs(eset.scdd))
colnames(cond) <- "condition"
sumExp <- SummarizedExperiment(assays=list("NormCounts"=exprs(eset.scdd)),
colData=cond)
rm(eset.scdd)
prior_param=list(alpha=0.01, mu0=0, s0=0.01, a0=0.01, b0=0.01)
SCdat <- sumExp
permutations=0
testZeroes=TRUE
testZeroes=FALSE
adjust.perms=FALSE
param=bpparam()
library(BiocParallel)
param=bpparam()
parallelBy <- "Genes"
condition="condition"
min.size=3
# check whether SCdat is a member of the SummarizedExperiment class
if(!("SummarizedExperiment" %in% class(SCdat))){
stop("Please provide a valid 'SummarizedExperiment' object.")
}
if (is.null(assayNames(SCdat)) || assayNames(SCdat)[1] != "NormCounts") {
message("renaming the first element in assays(SCdat) to 'NormCounts'")
assayNames(SCdat)[1] <- "NormCounts"
}
alpha = prior_param$alpha
m0 = prior_param$mu0
s0 = prior_param$s0
a0 = prior_param$a0
b0 = prior_param$b0
# check that condition inputs are valid
if (length(unique(colData(SCdat)[[condition]])) != 2 |
length(colData(SCdat)[[condition]]) != ncol(normExprs(SCdat))){
stop("Error: Please specify valid condition labels.")
}
# reference category/condition - the first listed one
ref <- unique(colData(SCdat)[[condition]])[1]
# check for genes that are all (or almost all) zeroes
tofit <- which(
(rowSums(normExprs(SCdat)[,colData(SCdat)[[condition]]==ref]>0) >=
max(min.size,2)) &
(rowSums(normExprs(SCdat)[,colData(SCdat)[[condition]]!=ref]>0) >=
max(min.size,2)))
if (length(tofit) < nrow(normExprs(SCdat))){
if(testZeroes){
message("Notice: There exist genes that are all (or almost all) zero.
For genes with 0 or 1 nonzero measurements per condition,
only testing for DZ")
}else{
message("Notice: There exist genes that are all (or almost all) zero.
Skipping genes with 0 or 1 nonzero measurements per condition")
}
}
# check for genes for which all nonzero values are identical within at least
# one of the conditions. These will cause problems in model fitting
skipConstant <- which(
apply(normExprs(SCdat)[tofit,
colData(SCdat)[[condition]]==ref], 1,
function(x) length(unique(x[x>0])) == 1) |
apply(normExprs(SCdat)[tofit,
colData(SCdat)[[condition]]!=ref], 1,
function(x) length(unique(x[x>0])) == 1) )
if (length(skipConstant) > 0){
if(testZeroes){
message("Notice: There exist genes with constant nonzero values.
These genes will only be considered for the DZ pattern.")
}else{
message("Notice: There exist genes with constant nonzero values.
Skipping these genes.")
}
tofit <- tofit[-skipConstant]
}
message("Clustering observed expression data for each gene")
message(paste0("Setting up parallel back-end using ",
param$workers, " cores" ))
BiocParallel::register(BPPARAM = param)
oa <- c1 <- c2 <- vector("list", nrow(normExprs(SCdat)[tofit,]))
bf <- den <- comps.all <-
comps.c1 <- comps.c2 <- rep(NA, nrow(normExprs(SCdat)[tofit,]))
genefit <- function(y){
cond0 <- colData(SCdat)[[condition]][y>0]
y <- log(y[y>0])
oa <- scDD::mclustRestricted(y, restrict=TRUE, min.size=min.size)
c1 <- scDD::mclustRestricted(y[cond0==ref], restrict=TRUE, min.size=min.size)
c2 <- scDD::mclustRestricted(y[cond0!=ref], restrict=TRUE, min.size=min.size)
return(list(
oa=oa,
c1=c1,
c2=c2
))
}
out <- bplapply(1:nrow(normExprs(SCdat)[tofit,]), function(x)
genefit(normExprs(SCdat)[tofit[x],]))
#' mclustRestricted
#'
#' Function to determine how many normal mixture components are present.
#'
#' @details Robust to detecting multiple components that are close together
#' by enforcing that the distance between two clusters
#'  of appreciable size (at least 4 samples), have sufficiently high bimodal
#'  index (cluster mean difference standardized by average
#'  standard deviation and multiplied by a balance factor which is one when
#'  clusters are perfectly balanced) and not have variances
#'  that differ by more than a ratio of 20. Bimodal index threshold is
#'  dependent on sample size to ensure consistent performance
#'  in power and type I error of detection of multiple components.
#'
#' @param y Numeric vector of values to fit to a normal mixture model with
#' Mclust.
#'
#' @param restrict Logical indicating whether or not to enforce the restriction
#'  on cluster separation based on bimodal index
#'   and ratio of largest to smallest variance (see details).  If False,
#'   then Mclust results as is are returned.
#'
#' @param min.size a positive integer that specifies the minimum size of a
#' cluster (number of cells) for it to be used
#'  during the classification step. A clustering with all clusters of
#'  size less than \code{min.size} is not valid and clusters will be merged if
#'  this happens.
#'
#' @importFrom mclust Mclust
#'
#' @references Korthauer KD, Chu LF, Newton MA, Li Y, Thomson J, Stewart R,
#' Kendziorski C. A statistical approach for identifying differential
#' distributions
#' in single-cell RNA-seq experiments. Genome Biology. 2016 Oct 25;17(1):222.
#'  \url{https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-
#'  1077-y}
#'
#' @return List object with (1) vector of cluster membership,
#' (2) cluster means, (3) cluster variances, (4) number of model parameters,
#'  (5) sample size, (6) BIC of selected model, and
#'  (6) loglikelihood of selected model.
#'
mclustRestricted <- function(y, restrict=TRUE, min.size){
# add runif(-0.1,0.1) jitter if all y vals are identical
if (length(unique(y))==1){
y <- y + runif(length(y), -0.1, 0.1)
}
mc <- suppressWarnings(Mclust(y, warn=FALSE, modelNames=c("V"), G=1:5))
cl <- mc$classification
comps <- mc$G
if(comps > length(unique(cl))){
mc <- suppressWarnings(Mclust(y, warn=FALSE,
modelNames=c("V"), G=1:(comps-1)))
cl <- mc$classification
comps <- mc$G
}
# Bimodal index threshold for removing a component (minimum of 1.6,
# increases with sample size and levels off at 2.2)
remThresh <- 1/(1+exp(-length(y)/60+0.4)) + 1.2
# Bimodal index threshold for keeping an added component (maximum of 4.0,
# but is 3.6 at sample size 50
# increases with sample size and levels off at 3.4
addThresh <- 1/(1+exp(length(y)/9-4.5)) + 3.4
if (restrict) {
if (comps > 1){
compmeans <- mc$parameters$mean
meandiff <- diff(compmeans)/max(sqrt(mc$parameters$variance$sigmasq))
max.cl <- which.max(mc$parameters$variance$sigmasq)
min.cl <- which.min(mc$parameters$variance$sigmasq)
vardiff <- mc$parameters$variance$sigmasq[max.cl] /
mc$parameters$variance$sigmasq[min.cl]
nmin <- table(cl)[min.cl]
mincat <- min(table(cl))
tries <- 0
nmax <- table(cl)[max.cl]
balance <- 2*sqrt(nmin*nmax/(nmin+nmax)^2)
meandiff <- meandiff*balance
# Error handling checks
if (length(vardiff)==0){
vardiff <- 1
}else if(sum(is.na(vardiff))>0){
vardiff <- 1
}
if (length(nmin)==0){
nmin <- Inf
}else if(is.na(nmin)){
nmin <- Inf
}
if (length(meandiff)==0){
meandiff <- Inf
}else if(sum(is.na(meandiff))>0){
meandiff <- Inf
}
if (length(mincat)==0){
mincat <- 1
}else if(is.na(mincat)){
mincat <- 1
}
err <- 0
# enforce that clusters have to be have sufficient bimodal index -
# if not, decrease possible components by 1 and refit
while( (min(meandiff) < remThresh | (vardiff > 20)) & mincat>2
& tries <=4 & sum(is.na(mc$class))==0 & err==0){
err <- 0
comps_old <- comps
comps <- comps-1
mc <- suppressWarnings(Mclust(y, warn=FALSE,
modelNames=c("V"), G=1:comps))
cl <- mc$classification
comps <- mc$G
mincat <- min(table(cl))
tries <- tries + 1
if (comps > 1 & comps_old-comps==1){
compmeans <- as.numeric(by(y, cl, mean))
meandiff <- diff(compmeans)/max(sqrt(mc$parameters$variance$sigmasq))
balance <- 2*sqrt(nmin*nmax/(nmin+nmax)^2)
meandiff <- meandiff*balance
max.cl <- which.max(mc$parameters$variance$sigmasq)
min.cl <- which.min(mc$parameters$variance$sigmasq)
vardiff <- mc$parameters$variance$sigmasq[max.cl] /
mc$parameters$variance$sigmasq[min.cl]
nmin <- table(cl)[min.cl]
}else{
meandiff <- 10
vardiff <- -Inf
nmin <- 100
}
# check for errors in new fit
if (length(vardiff)==0){
vardiff <- 1
err <- 1
}else if(sum(is.na(vardiff))>0){
vardiff <- 1
err <- 1
}
if (length(nmin)==0){
nmin <- Inf
err <- 1
}else if(is.na(nmin)){
nmin <- Inf
err <- 1
}
if (length(meandiff)==0){
meandiff <- Inf
err <- 1
}else if(sum(is.na(meandiff))>0){
meandiff <- Inf
err <- 1
}
if (length(mincat)==0){
mincat <- 1
err <- 1
}else if(is.na(mincat)){
mincat <- 1
err <- 1
}
# if fit resulted in any errors, revert to previous fit
if (err == 1){
comps <- comps+1
mc <- suppressWarnings(Mclust(y, warn=FALSE,
modelNames=c("V"), G=1:comps))
cl <- mc$classification
comps <- mc$G
}
}
}else{  # check whether to add a component if only identified one
comps_old <- comps
comps <- comps+1
mc <- tryCatch({suppressWarnings(Mclust(y, warn=FALSE,
modelNames=c("V"), G=comps))},
error = function(e) {return(NULL)})
cl <- mc$classification
if(!is.null(mc) & length(unique(cl))==comps){
mincat <- min(table(cl))
compmeans <- mc$parameters$mean
meandiff <- diff(compmeans)/max(sqrt(mc$parameters$variance$sigmasq))
max.cl <- which.max(mc$parameters$variance$sigmasq)
min.cl <- which.min(mc$parameters$variance$sigmasq)
vardiff <- mc$parameters$variance$sigmasq[max.cl] /
mc$parameters$variance$sigmasq[min.cl]
nmin <- table(cl)[min.cl]
mincat <- min(table(cl))
tries <- 0
nmax <- table(cl)[max.cl]
balance <- 2*sqrt(nmin*nmax/(nmin+nmax)^2)
meandiff <- meandiff*balance
if(!((min(meandiff) > addThresh & (vardiff < 10)) & mincat>2)){
mc <- suppressWarnings(Mclust(y, warn=FALSE,
modelNames=c("V"), G=comps_old))
cl <- mc$classification
comps <- mc$G
}
}else{ # couldn't fit requested model; revert to previous fit
mc <- suppressWarnings(Mclust(y, warn=FALSE,
modelNames=c("V"), G=comps_old))
cl <- mc$classification
comps <- mc$G
}
}
}
# if more than one cluster, and all clusters have less than min.size,
# merge clusters together
if (comps > 1 & max(table(cl)) < min.size){
comps <- comps-1
mc <- suppressWarnings(Mclust(y, warn=FALSE,
modelNames=c("V"), G=1:comps))
cl <- mc$classification
comps <- mc$G
}
# enforce clusters to have increasing means
cl2 <- cl
clust.order <- 1
if (comps > 1){
clust.order <- order(mc$parameters$mean)
nms.clust <- names(mc$parameters$mean[clust.order])
for (i in 1:comps){
cl2[cl==i] <- as.numeric(nms.clust[i])
}
}
return(list(class=cl2, mean=mc$parameters$mean[clust.order],
var=mc$parameters$variance$sigmasq[clust.order],
df=mc$df, n=mc$n, bic=mc$bic, loglik=mc$loglik,
model=mc$modelName))
}
out <- bplapply(1:nrow(normExprs(SCdat)[tofit,]), function(x)
genefit(normExprs(SCdat)[tofit[x],]))
genefit <- function(y){
cond0 <- colData(SCdat)[[condition]][y>0]
y <- log(y[y>0])
oa <- mclustRestricted(y, restrict=TRUE, min.size=min.size)
c1 <- mclustRestricted(y[cond0==ref], restrict=TRUE, min.size=min.size)
c2 <- mclustRestricted(y[cond0!=ref], restrict=TRUE, min.size=min.size)
return(list(
oa=oa,
c1=c1,
c2=c2
))
}
out <- bplapply(1:nrow(normExprs(SCdat)[tofit,]), function(x)
genefit(normExprs(SCdat)[tofit[x],]))
library(mclust)
out <- bplapply(1:nrow(normExprs(SCdat)[tofit,]), function(x)
genefit(normExprs(SCdat)[tofit[x],]))
library(scDD)
# read in dataset from Sara (object is named eset.scdd)
load("~/Desktop/scRNAseq/CODE/eset_forKeegan.rda")
# convert eset.scdd to SummarizedExperiment object compatible with new version
library(SummarizedExperiment )
cond <- data.frame(as.numeric(phenoData(eset.scdd)@data$condition))
rownames(cond) <- colnames(exprs(eset.scdd))
colnames(cond) <- "condition"
sumExp <- SummarizedExperiment(assays=list("NormCounts"=exprs(eset.scdd)),
colData=cond)
rm(eset.scdd)
# run scDD without permutations (KS version)
prior_param=list(alpha=0.01, mu0=0, s0=0.01, a0=0.01, b0=0.01)
sumExp <- scDD(sumExp, prior_param=prior_param,
permutations=0, testZeroes=TRUE)
# peek at results objects
# main results table
head(results(sumExp))
# gene by sample partition ests
results(sumExp, type="Zhat.combined")[1:5,1:5]
# look at categories
table(results(sumExp)$DDcategory)
# sum up how many genes were skipped (for the nonzero test) due to too few
# nonzero cells in each condition (default min.size is 3)
sum(is.na(results(sumExp)$nonzero.pvalue))
# SessionInfo
sessionInfo()
cond
table(cond)
?ks.test
ks.test(c(3,5,7), c(5.6, 9, 10))
t.test(c(3,5,7), c(5.6, 9, 10))
t.test(c(3,5,7,4), c(5.6, 9, 10,12))
ks.test(c(3,5,7,4), c(5.6, 9, 10,12))
ks.test(c(3,5,7,4,5,6), c(5.6, 9, 10,12,10,11))
t.test(c(3,5,7,4,5,6), c(5.6, 9, 10,12,10,11))
t.test(c(3,5,7,4,5,6,2), c(5.6, 9, 10,12,10,11,12))
ks.test(c(3,5,7,4,5,6,2), c(5.6, 9, 10,12,10,11,12))
library(scDD)
# read in dataset from Sara (object is named eset.scdd)
load("~/Desktop/scRNAseq/CODE/eset_forKeegan.rda")
# convert eset.scdd to SummarizedExperiment object compatible with new version
library(SummarizedExperiment )
cond <- data.frame(as.numeric(phenoData(eset.scdd)@data$condition))
rownames(cond) <- colnames(exprs(eset.scdd))
colnames(cond) <- "condition"
sumExp <- SummarizedExperiment(assays=list("NormCounts"=exprs(eset.scdd)),
colData=cond)
rm(eset.scdd)
show(sumExp)
ks.test(c(3,5,2), c(5.6, 9, 10,12,10,11,12))
t.test(c(3,5,2), c(5.6, 9, 10,12,10,11,12))
t.test(c(3,5,2), c(5.6, 9, 10,12,10,11,12, 15))
ks.test(c(3,5,2), c(5.6, 9, 10,12,10,11,12, 15))
library(scDD)
# read in dataset from Sara (object is named eset.scdd)
load("~/Desktop/scRNAseq/CODE/eset_forKeegan.rda")
# convert eset.scdd to SummarizedExperiment object compatible with new version
library(SummarizedExperiment )
cond <- data.frame(as.numeric(phenoData(eset.scdd)@data$condition))
rownames(cond) <- colnames(exprs(eset.scdd))
colnames(cond) <- "condition"
sumExp <- SummarizedExperiment(assays=list("NormCounts"=exprs(eset.scdd)),
colData=cond)
rm(eset.scdd)
# run scDD without permutations (KS version)
prior_param=list(alpha=0.01, mu0=0, s0=0.01, a0=0.01, b0=0.01)
sumExp <- scDD(sumExp, prior_param=prior_param,
permutations=0, testZeroes=TRUE, min.zero=10)
head(results(sumExp))
# gene by sample partition ests
results(sumExp, type="Zhat.combined")[1:5,1:5]
# look at categories
table(results(sumExp)$DDcategory)
# sum up how many genes were skipped (for the nonzero test) due to too few
# nonzero cells in each condition (default min.size is 3)
sum(is.na(results(sumExp)$nonzero.pvalue))
library(scDD)
# read in dataset from Sara (object is named eset.scdd)
load("~/Desktop/scRNAseq/CODE/eset_forKeegan.rda")
# convert eset.scdd to SummarizedExperiment object compatible with new version
library(SummarizedExperiment )
cond <- data.frame(as.numeric(phenoData(eset.scdd)@data$condition))
rownames(cond) <- colnames(exprs(eset.scdd))
colnames(cond) <- "condition"
sumExp <- SummarizedExperiment(assays=list("NormCounts"=exprs(eset.scdd)),
colData=cond)
rm(eset.scdd)
# run scDD without permutations (KS version)
prior_param=list(alpha=0.01, mu0=0, s0=0.01, a0=0.01, b0=0.01)
sumExp <- scDD(sumExp, prior_param=prior_param,
permutations=0, testZeroes=TRUE, min.zero=10)
library(scDD)
# read in dataset from Sara (object is named eset.scdd)
load("~/Desktop/scRNAseq/CODE/eset_forKeegan.rda")
# convert eset.scdd to SummarizedExperiment object compatible with new version
library(SummarizedExperiment )
cond <- data.frame(as.numeric(phenoData(eset.scdd)@data$condition))
rownames(cond) <- colnames(exprs(eset.scdd))
colnames(cond) <- "condition"
sumExp <- SummarizedExperiment(assays=list("NormCounts"=exprs(eset.scdd)),
colData=cond)
rm(eset.scdd)
# run scDD without permutations (KS version)
prior_param=list(alpha=0.01, mu0=0, s0=0.01, a0=0.01, b0=0.01)
sumExp <- scDD(sumExp, prior_param=prior_param,
permutations=0, testZeroes=TRUE, min.zero=3)
library(scDD)
setwd("~/Desktop/scDD")
library(devtools)
?install_github
