{
    "collab_server" : "",
    "contents" : "#' mclustRestricted\n#'\n#' Function to determine how many normal mixture components are present.\n#' \n#' @details Robust to detecting multiple components that are close together \n#' by enforcing that the distance between two clusters \n#'  of appreciable size (at least 4 samples), have sufficiently high bimodal \n#'  index (cluster mean difference standardized by average\n#'  standard deviation and multiplied by a balance factor which is one when \n#'  clusters are perfectly balanced) and not have variances\n#'  that differ by more than a ratio of 20. Bimodal index threshold is \n#'  dependent on sample size to ensure consistent performance\n#'  in power and type I error of detection of multiple components. \n#' \n#' @param y Numeric vector of values to fit to a normal mixture model with \n#' Mclust.\n#' \n#' @param restrict Logical indicating whether or not to enforce the restriction\n#'  on cluster separation based on bimodal index\n#'   and ratio of largest to smallest variance (see details).  If False, \n#'   then Mclust results as is are returned.\n#'   \n#' @param min.size a positive integer that specifies the minimum size of a \n#' cluster (number of cells) for it to be used\n#'  during the classification step. A clustering with all clusters of \n#'  size less than \\code{min.size} is not valid and clusters will be merged if \n#'  this happens.\n#'   \n#' @importFrom mclust Mclust\n#' \n#' @references Korthauer KD, Chu LF, Newton MA, Li Y, Thomson J, Stewart R, \n#' Kendziorski C. A statistical approach for identifying differential \n#' distributions\n#' in single-cell RNA-seq experiments. Genome Biology. 2016 Oct 25;17(1):222.\n#'  \\url{https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-\n#'  1077-y}\n#' \n#' @return List object with (1) vector of cluster membership, \n#' (2) cluster means, (3) cluster variances, (4) number of model parameters,\n#'  (5) sample size, (6) BIC of selected model, and \n#'  (6) loglikelihood of selected model. \n#' \n\n\n\nmclustRestricted <- function(y, restrict=TRUE, min.size){\n  # add runif(-0.1,0.1) jitter if all y vals are identical\n  if (length(unique(y))==1){\n    y <- y + runif(length(y), -0.1, 0.1)\n  }\n  \n  mc <- suppressWarnings(Mclust(y, warn=FALSE, modelNames=c(\"V\"), G=1:5))\t\n  cl <- mc$classification\n  comps <- mc$G\n  \n  if(comps > length(unique(cl))){\n    mc <- suppressWarnings(Mclust(y, warn=FALSE, \n                                  modelNames=c(\"V\"), G=1:(comps-1)))\n    cl <- mc$classification\n    comps <- mc$G\n  }\n  \n  # Bimodal index threshold for removing a component (minimum of 1.6, \n  # increases with sample size and levels off at 2.2)\n  remThresh <- 1/(1+exp(-length(y)/60+0.4)) + 1.2\n  \n  # Bimodal index threshold for keeping an added component (maximum of 4.0,\n  # but is 3.6 at sample size 50\n  # increases with sample size and levels off at 3.4\n  addThresh <- 1/(1+exp(length(y)/9-4.5)) + 3.4\n  \n  if (restrict) { \n    if (comps > 1){\n      compmeans <- mc$parameters$mean\n      meandiff <- diff(compmeans)/max(sqrt(mc$parameters$variance$sigmasq))\n      \n      max.cl <- which.max(mc$parameters$variance$sigmasq)\n      min.cl <- which.min(mc$parameters$variance$sigmasq)\n      vardiff <- mc$parameters$variance$sigmasq[max.cl] / \n        mc$parameters$variance$sigmasq[min.cl]\n      nmin <- table(cl)[min.cl]\n      mincat <- min(table(cl))\n      tries <- 0\t\n      nmax <- table(cl)[max.cl]\n      balance <- 2*sqrt(nmin*nmax/(nmin+nmax)^2)\n      meandiff <- meandiff*balance\n      \n      # Error handling checks\n      if (length(vardiff)==0){\n        vardiff <- 1\n      }else if(sum(is.na(vardiff))>0){\n        vardiff <- 1\n      }\n      if (length(nmin)==0){\n        nmin <- Inf\n      }else if(is.na(nmin)){\n        nmin <- Inf\n      }\n      if (length(meandiff)==0){\n        meandiff <- Inf\n      }else if(sum(is.na(meandiff))>0){\n        meandiff <- Inf\n      }\n      if (length(mincat)==0){\n        mincat <- 1\n      }else if(is.na(mincat)){\n        mincat <- 1\n      }\n      \n      err <- 0\n      # enforce that clusters have to be have sufficient bimodal index -\n      # if not, decrease possible components by 1 and refit\n      while( (min(meandiff) < remThresh | (vardiff > 20)) & mincat>2 \n             & tries <=4 & sum(is.na(mc$class))==0 & err==0){\n         err <- 0\n        comps_old <- comps\n        comps <- comps-1 \n        mc <- suppressWarnings(Mclust(y, warn=FALSE, \n                                      modelNames=c(\"V\"), G=1:comps))\n        cl <- mc$classification\n        comps <- mc$G\n        mincat <- min(table(cl))\n        \n        tries <- tries + 1\n        if (comps > 1 & comps_old-comps==1){\n          compmeans <- as.numeric(by(y, cl, mean))\n          meandiff <- diff(compmeans)/max(sqrt(mc$parameters$variance$sigmasq))\n          balance <- 2*sqrt(nmin*nmax/(nmin+nmax)^2)\n          meandiff <- meandiff*balance\n          \n          max.cl <- which.max(mc$parameters$variance$sigmasq)\n          min.cl <- which.min(mc$parameters$variance$sigmasq)\n          vardiff <- mc$parameters$variance$sigmasq[max.cl] / \n            mc$parameters$variance$sigmasq[min.cl]\n          nmin <- table(cl)[min.cl]\n        }else{\n          meandiff <- 10\n          vardiff <- -Inf\n          nmin <- 100\n        }\n        \n        # check for errors in new fit\n        if (length(vardiff)==0){\n          vardiff <- 1\n          err <- 1\n        }else if(sum(is.na(vardiff))>0){\n          vardiff <- 1\n          err <- 1\n        }\n        if (length(nmin)==0){\n          nmin <- Inf\n          err <- 1\n        }else if(is.na(nmin)){\n          nmin <- Inf\n          err <- 1\n        }\n        if (length(meandiff)==0){\n          meandiff <- Inf\n          err <- 1\n        }else if(sum(is.na(meandiff))>0){\n          meandiff <- Inf\n          err <- 1\n        }\n        if (length(mincat)==0){\n          mincat <- 1\n          err <- 1\n        }else if(is.na(mincat)){\n          mincat <- 1\n          err <- 1\n        }\n        \n        # if fit resulted in any errors, revert to previous fit\n        if (err == 1){\n          comps <- comps+1 \n          mc <- suppressWarnings(Mclust(y, warn=FALSE, \n                                        modelNames=c(\"V\"), G=1:comps))\n          cl <- mc$classification\n          comps <- mc$G\n        }\n        \n      }\n    }else{  # check whether to add a component if only identified one\n      comps_old <- comps\n      comps <- comps+1 \n      mc <- tryCatch({suppressWarnings(Mclust(y, warn=FALSE, \n                                              modelNames=c(\"V\"), G=comps))},\n                      error = function(e) {return(NULL)})\n      cl <- mc$classification\n      \n      if(!is.null(mc) & length(unique(cl))==comps){ \n        mincat <- min(table(cl)) \n        compmeans <- mc$parameters$mean\n        meandiff <- diff(compmeans)/max(sqrt(mc$parameters$variance$sigmasq))\n        \n        max.cl <- which.max(mc$parameters$variance$sigmasq)\n        min.cl <- which.min(mc$parameters$variance$sigmasq)\n        vardiff <- mc$parameters$variance$sigmasq[max.cl] / \n          mc$parameters$variance$sigmasq[min.cl]\n        nmin <- table(cl)[min.cl]\n        mincat <- min(table(cl))\n        tries <- 0\t\n        nmax <- table(cl)[max.cl]\n        balance <- 2*sqrt(nmin*nmax/(nmin+nmax)^2)\n        meandiff <- meandiff*balance\n        \n        if(!((min(meandiff) > addThresh & (vardiff < 10)) & mincat>2)){\n          mc <- suppressWarnings(Mclust(y, warn=FALSE, \n                                        modelNames=c(\"V\"), G=comps_old))\n          cl <- mc$classification\n          comps <- mc$G\n        }\n      }else{ # couldn't fit requested model; revert to previous fit\n        mc <- suppressWarnings(Mclust(y, warn=FALSE, \n                                      modelNames=c(\"V\"), G=comps_old))\n        cl <- mc$classification\n        comps <- mc$G\n      }\n    }\n  }\n  \n  # if more than one cluster, and all clusters have less than min.size,\n  # merge clusters together\n  if (comps > 1 & max(table(cl)) < min.size){\n    comps <- comps-1 \n    mc <- suppressWarnings(Mclust(y, warn=FALSE, \n                                  modelNames=c(\"V\"), G=1:comps))\n    cl <- mc$classification\n    comps <- mc$G\n  }\n  \n  # enforce clusters to have increasing means\n  cl2 <- cl\n  clust.order <- 1\n  if (comps > 1){\n    clust.order <- order(mc$parameters$mean)\n    nms.clust <- names(mc$parameters$mean[clust.order])\n    for (i in 1:comps){\n      cl2[cl==i] <- as.numeric(nms.clust[i])\n    }\n  }\n  return(list(class=cl2, mean=mc$parameters$mean[clust.order], \n              var=mc$parameters$variance$sigmasq[clust.order], \n              df=mc$df, n=mc$n, bic=mc$bic, loglik=mc$loglik, \n              model=mc$modelName))\n}\n",
    "created" : 1482160004328.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "823894500",
    "id" : "73AC78C8",
    "lastKnownWriteTime" : 1482164146,
    "last_content_update" : 1482164146,
    "path" : "~/Desktop/scDD/R/mclust.restricted.R",
    "project_path" : "R/mclust.restricted.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}