{
    "collab_server" : "",
    "contents" : "#' scDD\n#' \n#' Find genes with differential distributions (DD) across two conditions\n#' \n#' @details Find genes with differential distributions (DD) across two \n#' conditions.  Models each log-transformed gene as a Dirichlet \n#'   Process Mixture of normals and uses a permutation test to determine \n#'   whether condition membership is independent of sample clustering.\n#'   The FDR adjusted (Benjamini-Hochberg) permutation p-value is returned \n#'   along with the classification of each significant gene \n#'   (with p-value less than 0.05 (or 0.025 if also testing for a difference\n#'    in the proportion of zeroes)) into one of four categories \n#'   (DE, DP, DM, DB).  For genes that do not show significant influence, \n#'   of condition on clustering, an optional test of whether the \n#'   proportion of zeroes (dropout rate) is different across conditions is \n#'   performed (DZ).\n#'   \n#' @param SCdat An object of class \\code{SummarizedExperiment} that contains \n#' normalized single-cell expression and metadata. The \\code{assays} \n#'   slot contains a named list of matrices, where the normalized counts are \n#'   housed in the one named \\code{\"NormCounts\"}.  This matrix should have one\n#'    row for each gene and one sample for each column.  \n#'   The \\code{colData} slot should contain a data.frame with one row per \n#'   sample and columns that contain metadata for each sample.  This data.frame\n#'   should contain a variable that represents biological condition, which is \n#'   in the form of numeric values (either 1 or 2) that indicates which \n#'   condition each sample belongs to (in the same order as the columns of \n#'   \\code{NormCounts}).  Optional additional metadata about each cell can also\n#'   be contained in this data.frame, and additional information about the \n#'   experiment can be contained in the \\code{metadata} slot as a list.\n#' \n#' @param prior_param A list of prior parameter values to be used when modeling\n#'  each gene as a mixture of DP normals.  Default \n#'    values are given that specify a vague prior distribution on the \n#'    cluster-specific means and variances.\n#'    \n#' @param permutations The number of permutations to be used in calculating \n#' empirical p-values.  If set to zero (default),\n#'   the full Bayes Factor permutation test will not be performed.  Instead, \n#'   a fast procedure to identify the genes with significantly different\n#'   expression distributions will be performed using the nonparametric \n#'   Kolmogorov-Smirnov test, which tests the null hypothesis that \n#'   the samples are generated from the same continuous distribution.  \n#'   This test will yield\n#'   slightly lower power than the full permutation testing framework \n#'   (this effect is more pronounced at smaller sample \n#'   sizes, and is more pronounced in the DB category), but is orders of \n#'   magnitude faster.  This option\n#'   is recommended when compute resources are limited.  The remaining \n#'   steps of the scDD framework will remain unchanged\n#'   (namely, categorizing the significant DD genes into patterns that \n#'   represent the major distributional changes, \n#'   as well as the ability to visualize the results with violin plots \n#'   using the \\code{sideViolin} function).\n#' \n#' @param testZeroes Logical indicating whether or not to test for a \n#' difference in the proportion of zeroes\n#' \n#' @param adjust.perms Logical indicating whether or not to adjust the \n#' permutation tests for the sample\n#'   detection rate (proportion of nonzero values).  If true, the \n#'   residuals of a linear model adjusted for \n#'   detection rate are permuted, and new fitted values are \n#'   obtained using these residuals.\n#'  \n#' @param param a \\code{MulticoreParam} or \\code{SnowParam} object of \n#' the \\code{BiocParallel}\n#' package that defines a parallel backend.  The default option is \n#' \\code{BiocParallel::bpparam()} which will automatically creates a cluster \n#' appropriate for \n#' the operating system.  Alternatively, the user can specify the number\n#' of cores they wish to use by first creating the corresponding \n#' \\code{MulticoreParam} (for Linux-like OS) or \\code{SnowParam} (for Windows)\n#' object, and then passing it into the \\code{scDD}\n#' function. This could be done to specify a parallel backend on a Linux-like\n#' OS with, say 12 \n#' cores by setting \\code{param=BiocParallel::MulticoreParam(workers=12)}\n#'  \n#' @param parallelBy For the permutation test (if invoked), the manner in \n#' which to parallelize.  The default option\n#'  is \\code{\"Genes\"} which will spawn processes that divide up the genes \n#'  across all cores defined in \\code{param} cores, and then loop through the \n#'  permutations. \n#'  The alternate option is \\code{\"Permutations\"} which\n#'  loop through each gene and spawn processes that divide up the permutations \n#'  across all cores defined in \\code{param}.  \n#'  The default option is recommended when analyzing more genes than the number\n#'   of permutations.\n#' \n#' @param condition A character object that contains the name of the column in \n#' \\code{colData} that represents \n#'  the biological group or condition of interest (e.g. treatment versus \n#'  control).  Note that this variable should only contain two \n#'  possible values since \\code{scDD} can currently only handle two-group \n#'  comparisons.  The default option assumes that there\n#'  is a column named \"condition\" that contains this variable. \n#'  \n#' @param min.size a positive integer that specifies the minimum size of a \n#' cluster (number of cells) for it to be used\n#'  during the classification step.  Any clusters containing fewer than \n#'  \\code{min.size} cells will be considered an outlier\n#'  cluster and ignored in the classfication algorithm.  The default value\n#'   is three.\n#'   \n#' @param min.nonzero a positive integer that specifies the minimum number of\n#' nonzero cells in each condition required for the test of differential \n#' distributions.  If a gene has fewer nonzero cells per condition, it will\n#' still be tested for DZ (if \\code{testZeroes} is TRUE). Default value is\n#' NULL (no minimum value is enforced).      \n#' \n#' @return A \\code{SummarizedExperiment} object that contains the data and \n#' sample information from the input object, but where the results objects\n#' are now added to the \\code{metadata} slot.  The metadata slot is now a\n#' list with four items: the first (main results object) is a data.frame \n#' with nine columns: \n#' gene name (matches rownames of SCdat), permutation p-value for testing of \n#' independence of \n#'  condition membership with clustering, Benjamini-Hochberg adjusted version \n#'  of the previous column, p-value for test of difference in dropout rate\n#'   (only for non-DD genes), \n#'  Benjamini-Hochberg adjusted version of the previous column, name of the \n#'  DD (DE, DP, DM, DB) pattern or DZ (otherwise NS = not significant), the \n#'  number of clusters identified overall, the number of clusters identified in \n#'  condition 1 alone, and the number of clusters identified in condition \n#'  2 alone. The remaining three elements are matrices (first for condition\n#'   1 and 2 combined, \n#'  then condition 1 alone, then condition 2 alone) that contains the cluster\n#'   memberships for each sample (cluster 1,2,3,...) in columns and\n#'  genes in rows.  Zeroes, which are not involved in the clustering, are\n#'   labeled as zero.  See the \\code{results} function for a convenient\n#'   way to extract these results objects.\n#'  \n#' @export\n#'\n#' @importFrom BiocParallel bplapply  \n#' \n#' @importFrom BiocParallel register\n#' \n#' @importFrom BiocParallel MulticoreParam\n#' \n#' @importFrom parallel detectCores\n#' \n#' @import SummarizedExperiment \n#' \n#' @references Korthauer KD, Chu LF, Newton MA, Li Y, Thomson J, Stewart R, \n#' Kendziorski C. A statistical approach for identifying differential \n#' distributions\n#' in single-cell RNA-seq experiments. Genome Biology. 2016 Oct 25;17(1):222. \n#' \\url{https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-\n#' 1077-y}\n#'  \n#' @examples \n#'  \n#' # load toy simulated example SummarizedExperiment to find DD genes\n#' \n#' data(scDatExSim)\n#' \n#' \n#' # check that this object is a member of the SummarizedExperiment class\n#' # and that it contains 200 samples and 30 genes\n#' \n#' class(scDatExSim)\n#' show(scDatExSim)\n#' \n#' \n#' # set arguments to pass to scDD function\n#' # we will perform 100 permutations on each of the 30 genes\n#' \n#' prior_param=list(alpha=0.01, mu0=0, s0=0.01, a0=0.01, b0=0.01)\n#' nperms <- 100\n#' \n#' \n#' # call the scDD function to perform permutations, classify DD genes, \n#' # and return results\n#' # we won't perform the test for a difference in the proportion of zeroes  \n#' # since none exists in this simulated toy example data\n#' # this step will take significantly longer with more genes and/or \n#' # more permutations\n#' \n#' scDatExSim <- scDD(scDatExSim, prior_param=prior_param, permutations=nperms, \n#'             testZeroes=FALSE)\n\nscDD <- function(SCdat, \n                 prior_param=list(alpha=0.10, mu0=0, s0=0.01, a0=0.01, b0=0.01),\n                 permutations=0,\n                 testZeroes=TRUE, adjust.perms=FALSE, \n                 param=bpparam(), \n                 parallelBy=c(\"Genes\", \"Permutations\"),\n                 condition=\"condition\", min.size=3,\n                 min.nonzero=NULL){\n  \n  # check whether SCdat is a member of the SummarizedExperiment class\n  if(!(\"SummarizedExperiment\" %in% class(SCdat))){\n    stop(\"Please provide a valid 'SummarizedExperiment' object.\")\n  }\n  \n  if (is.null(assayNames(SCdat)) || assayNames(SCdat)[1] != \"NormCounts\") {\n    message(\"renaming the first element in assays(SCdat) to 'NormCounts'\")\n    assayNames(SCdat)[1] <- \"NormCounts\"\n  }\n  \n  parallelBy <- match.arg(parallelBy)\n  \n  # unpack prior param objects\n  alpha = prior_param$alpha\n  m0 = prior_param$mu0\n  s0 = prior_param$s0\n  a0 = prior_param$a0\n  b0 = prior_param$b0\n  \n  # check that condition inputs are valid\n  if (length(unique(colData(SCdat)[[condition]])) != 2 | \n      length(colData(SCdat)[[condition]]) != ncol(normExprs(SCdat))){\n    stop(\"Error: Please specify valid condition labels.\")\n  }\n  \n  # reference category/condition - the first listed one\n  ref <- unique(colData(SCdat)[[condition]])[1]\n  \n  # check for genes that are all (or almost all) zeroes\n  if (is.null(min.nonzero)){\n    min.nonzero <- min.size\n  }\n  tofit <- which(\n           (rowSums(normExprs(SCdat)[,colData(SCdat)[[condition]]==ref]>0) >= \n             max(min.size,2,min.nonzero)) &\n           (rowSums(normExprs(SCdat)[,colData(SCdat)[[condition]]!=ref]>0) >= \n              max(min.size,2,min.nonzero)))\n  \n  if (length(tofit) < nrow(normExprs(SCdat))){\n    if(testZeroes){\n      message(paste0(\"Notice: \", nrow(normExprs(SCdat))-length(tofit), \n              \" genes have less than \", min.nonzero, \n              \" nonzero cells per condition. \",\n              \" Only testing for DZ for these genes.\"))  \n    }else{\n      message(paste0(\"Notice: \", nrow(normExprs(SCdat))-length(tofit), \n                     \" genes have less than \", min.nonzero, \n                     \" nonzero cells per condition. \",\n                     \" Skipping these genes.\"))  \n    }\n  }\n  \n  # check for genes for which all nonzero values are identical within at least \n  # one of the conditions. These will cause problems in model fitting\n  skipConstant <- which( \n                apply(normExprs(SCdat)[tofit,\n                                       colData(SCdat)[[condition]]==ref], 1,\n                                function(x) length(unique(x[x>0])) == 1) |\n                apply(normExprs(SCdat)[tofit,\n                                       colData(SCdat)[[condition]]!=ref], 1,\n                                function(x) length(unique(x[x>0])) == 1) )\n  if (length(skipConstant) > 0){\n    if(testZeroes){\n      message(paste0(\"Notice: \", length(skipConstant), \n                     \" Genes have constant nonzero values. \", \n                     \" Only testing for DZ for these genes.\"))  \n    }else{\n      message(paste0(\"Notice: \", length(skipConstant), \n                     \" Genes have constant nonzero values. \", \n                     \" Skipping these genes.\"))  \n    }\n    tofit <- tofit[-skipConstant]\n  }\n  \n  # cluster each gene in SCdat\n  message(\"Clustering observed expression data for each gene\")\n\n  message(paste0(\"Setting up parallel back-end using \", \n                 param$workers, \" cores\" ))\n  BiocParallel::register(BPPARAM = param)\n  \n  oa <- c1 <- c2 <- vector(\"list\", nrow(normExprs(SCdat)[tofit,]))\n  bf <- den <- comps.all <- \n    comps.c1 <- comps.c2 <- rep(NA, nrow(normExprs(SCdat)[tofit,]))\n  \n  if (permutations == 0){\n\n    # function to fit one gene \n    genefit <- function(y){\n      cond0 <- colData(SCdat)[[condition]][y>0]\n      y <- log(y[y>0])\n      \n      oa <- mclustRestricted(y, restrict=TRUE, min.size=min.size)\n      c1 <- mclustRestricted(y[cond0==ref], restrict=TRUE, min.size=min.size)\n      c2 <- mclustRestricted(y[cond0!=ref], restrict=TRUE, min.size=min.size)\n    \n      return(list(\n        oa=oa,\n        c1=c1,\n        c2=c2\n      ))\n    }\n    \n    out <- bplapply(1:nrow(normExprs(SCdat)[tofit,]), function(x) \n      genefit(normExprs(SCdat)[tofit[x],]))\n    oa <- lapply(out, function(x) x[[\"oa\"]])\n    c1 <- lapply(out, function(x) x[[\"c1\"]])\n    c2 <- lapply(out, function(x) x[[\"c2\"]])\n    rm(out); gc()\n    \n    comps.all <- unlist(lapply(oa, function(x) luOutlier(x$class, min.size)))\n    comps.c1  <- unlist(lapply(c1, function(x) luOutlier(x$class, min.size)))\n    comps.c2  <- unlist(lapply(c2, function(x) luOutlier(x$class, min.size)))\n    \n    message(\"Notice: Number of permutations is set to zero; using \n            Kolmogorov-Smirnov to test for differences in distributions\n            instead of the Bayes Factor permutation test\")\n    \n    res_ks <- testKS(normExprs(SCdat)[tofit,], \n                     colData(SCdat)[[condition]], inclZero=FALSE)\n    \n    if (testZeroes){\n      sig <- which(res_ks$p < 0.025)\n    }else{\n      sig <- which(res_ks$p < 0.05)\n    }\n    \n    pvals <- res_ks$p.unadj\n    \n  }else{ \n\n    # function to fit one gene \n    genefit <- function(y){\n      cond0 <- colData(SCdat)[[condition]][y>0]\n      y <- log(y[y>0])\n      \n      oa <- mclustRestricted(y, restrict=TRUE, min.size=min.size)\n      c1 <- mclustRestricted(y[cond0==ref], restrict=TRUE, min.size=min.size)\n      c2 <- mclustRestricted(y[cond0!=ref], restrict=TRUE, min.size=min.size)\n      \n      bf <- jointPosterior(y[cond0==ref], c1, alpha, m0, s0, a0, b0) + \n        jointPosterior(y[cond0!=ref], c2, alpha, m0, s0, a0, b0) \n      den <- jointPosterior(y, oa, alpha, m0, s0, a0, b0)\n      return(list(\n        oa=oa,\n        c1=c1,\n        c2=c2,\n        bf=bf,\n        den=den\n      ))\n    }\n    \n    out <- bplapply(1:nrow(normExprs(SCdat)[tofit,]), function(x) \n      genefit(normExprs(SCdat)[tofit[x],]))\n    oa <- lapply(out, function(x) x[[\"oa\"]])\n    c1 <- lapply(out, function(x) x[[\"c1\"]])\n    c2 <- lapply(out, function(x) x[[\"c2\"]])\n    bf <- unlist(lapply(out, function(x) x[[\"bf\"]]))\n    den<- unlist(lapply(out, function(x) x[[\"den\"]]))\n    rm(out); gc()\n    \n    comps.all <- unlist(lapply(oa, function(x) luOutlier(x$class, min.size)))\n    comps.c1  <- unlist(lapply(c1, function(x) luOutlier(x$class, min.size)))\n    comps.c2  <- unlist(lapply(c2, function(x) luOutlier(x$class, min.size)))\n  \n\n      # obtain Bayes Factor score numerators for each permutation\n      message(\"Performing permutations to evaluate independence of clustering\n              and condition for each gene\")\n      message(paste0(\"Parallelizing by \", parallelBy))\n      bf.perm <- vector(\"list\", nrow(normExprs(SCdat)[tofit,]))\n      names(bf.perm) <- rownames(normExprs(SCdat)[tofit,])\n      \n      if(parallelBy==\"Permutations\"){\n        if(adjust.perms){\n          C <- apply(normExprs(SCdat)[tofit,], 2, \n                     function(x) sum(x>0)/length(x))\n          \n          t1 <- proc.time()\n          for (g in 1:nrow(normExprs(SCdat)[tofit,])){\n            bf.perm[[g]] <- permMclustCov(normExprs(SCdat)[tofit[g],], \n                                          permutations, C, \n                                          colData(SCdat)[[condition]], \n                                          remove.zeroes=TRUE, \n                                          log.transf=TRUE, restrict=TRUE,\n                                          min.size=min.size,\n                                          alpha, m0, s0, a0, b0, ref)\n            \n            if (g%%1000 == 0){\n              t2 <- proc.time()\n              message(paste0(g, \" genes completed at \", date(), \", took \", \n                             round((t2-t1)[3]/60, 2), \" minutes\")) \n              t1 <- t2\n            }\n          }\n          \n        }else{\n          t1 <- proc.time()\n          for (g in 1:nrow(normExprs(SCdat)[tofit,])){\n            bf.perm[[g]] <- permMclust(normExprs(SCdat[tofit[g],]), \n                                       permutations,\n                                       colData(SCdat)[[condition]], \n                                       remove.zeroes=TRUE, log.transf=TRUE, \n                                       restrict=TRUE,\n                                       min.size=min.size, \n                                       alpha, m0, s0, a0, b0, ref)\n            \n            if (g%%1000 == 0){\n              t2 <- proc.time()\n              message(paste0(g, \" genes completed at \", date(), \", took \", \n                             round((t2-t1)[3]/60, 2), \" minutes\")) \n              t1 <- t2\n            }\n          }\n      }\n      }else if(parallelBy==\"Genes\"){\n        C <- apply(normExprs(SCdat)[tofit,], 2, function(x) sum(x>0)/length(x))\n        bf.perm <- bplapply(1:nrow(normExprs(SCdat)[tofit,]), function(x) \n              permMclustGene(normExprs(SCdat)[tofit[x],], adjust.perms, \n                             permutations, colData(SCdat)[[condition]], \n                             remove.zeroes=TRUE, log.transf=TRUE, restrict=TRUE,\n                             min.size=min.size,\n                             alpha, m0, s0, a0, b0, C, ref))\n      }else{stop(\"Please specify either 'Permutations' or 'Genes' to \n                 parallelize by using the parallelizeBy argument\")}\n      \n      if (adjust.perms){\n        pvals <- sapply(1:nrow(normExprs(SCdat)[tofit,]), function(x) \n          sum( bf.perm[[x]] > bf[x] - den[x] ) )/(permutations)\n      }else{\n        pvals <- sapply(1:nrow(normExprs(SCdat)[tofit,]), function(x) \n          sum( bf.perm[[x]] > bf[x]) ) / (permutations)\n      }\n      \n      if (testZeroes){\n        sig <- which(p.adjust(pvals, method=\"BH\") < 0.025)\n      }else{\n        sig <- which(p.adjust(pvals, method=\"BH\") < 0.05)\n      }\n  }\n  \n  message(\"Classifying significant genes into patterns\")\n  dd.cats <- classifyDD(normExprs(SCdat)[tofit,], colData(SCdat)[[condition]],\n                        sig, oa, c1, c2, alpha=alpha, \n                        m0=m0, s0=s0, a0=a0, b0=b0, \n                        log.nonzero=TRUE, ref=ref, min.size=min.size)\n  \n  cats <- rep(\"NS\", nrow(normExprs(SCdat)[tofit,]))\n  cats[sig] <- dd.cats\n  \n  extraDP <- feDP(normExprs(SCdat)[tofit,], colData(SCdat)[[condition]], \n                  sig, oa, c1, c2, log.nonzero=TRUE,\n                  testZeroes=testZeroes, adjust.perms=adjust.perms, \n                  min.size=min.size)\n  cats[-sig] <- names(extraDP)\n  \n  # classify additional genes with evidence of DD in \n  # the form of a mean shift found by 'extraDP'\n  if(testZeroes){\n    NCs <- which(p.adjust(pvals, method=\"BH\") > 0.025 & cats == \"NC\")\n  }else{\n    NCs <- which(p.adjust(pvals, method=\"BH\") > 0.05 & cats == \"NC\")\n  }\n  NC.cats <- classifyDD(normExprs(SCdat)[tofit,], colData(SCdat)[[condition]],\n                        NCs, oa, c1, c2, alpha=alpha, \n                        m0=m0, s0=s0, a0=a0, b0=b0, log.nonzero=TRUE, \n                        ref=ref, min.size=min.size)\n  cats[NCs] <- NC.cats\n  \n  cats.all <- pvals.all <- rep(NA, nrow(normExprs(SCdat)))\n  cats.all[tofit] <- cats\n  pvals.all[tofit] <- pvals\n   \n  # zero test\n  ns <- which(!(cats.all %in% c(\"DE\", \"DP\", \"DM\", \"DB\")))\n  pvals.z <- rep(NA, nrow(normExprs(SCdat)))\n  if (testZeroes){\n    ztest <- testZeroes(normExprs(SCdat), colData(SCdat)[[condition]], ns)\n    pvals.z[ns] <- ztest\n    cats.all[p.adjust(pvals.z, method=\"BH\") < 0.025] <- \"DZ\"\n    cats.all[p.adjust(pvals.z, method=\"BH\") >= 0.025] <- \"NS\"\n  }\n  \n  # build MAP objects\n  MAP1 <- matrix(1, nrow=nrow(normExprs(SCdat)), \n                 ncol=sum(colData(SCdat)[[condition]]==ref))\n  MAP2 <- matrix(1, nrow=nrow(normExprs(SCdat)), \n                 ncol=sum(colData(SCdat)[[condition]]!=ref))\n  MAP <- matrix(1, nrow=nrow(normExprs(SCdat)), \n                ncol=ncol(normExprs(SCdat)))\n  rownames(MAP1) <- rownames(MAP2) <- rownames(MAP) <- rownames(SCdat)\n  colnames(MAP1) <- colnames(SCdat[,colData(SCdat)[[condition]]==ref])\n  colnames(MAP2) <- colnames(SCdat[,colData(SCdat)[[condition]]!=ref])\n  colnames(MAP) <- colnames(SCdat)\n  MAP1[normExprs(SCdat)[, colData(SCdat)[[condition]]==ref]==0] <- 0\n  MAP2[normExprs(SCdat)[, colData(SCdat)[[condition]]!=ref]==0] <- 0\n  MAP[normExprs(SCdat)==0] <- 0\n  \n  for (g in 1:nrow(normExprs(SCdat)[tofit,])){\n    MAP1[tofit[g],][normExprs(SCdat[tofit[g], \n                colData(SCdat)[[condition]]==ref])!=0] <- c1[[g]]$class \n    MAP2[tofit[g],][normExprs(SCdat[tofit[g], \n                colData(SCdat)[[condition]]!=ref])!=0] <- c2[[g]]$class\n    MAP[tofit[g],][normExprs(SCdat[tofit[g], ])!=0] <- oa[[g]]$class\n  }\n  \n  comps.all.ALL <- comps.c1.ALL <- comps.c2.ALL <- rep(NA, \n                                                       nrow(normExprs(SCdat)))\n  comps.all.ALL[tofit] <- comps.all\n  comps.c1.ALL[tofit] <- comps.c1\n  comps.c2.ALL[tofit] <- comps.c2\n  \n  Genes = data.frame(gene=rownames(SCdat), \n                   nonzero.pvalue=pvals.all,\n                   nonzero.pvalue.adj=p.adjust(pvals.all, method=\"BH\"), \n                   zero.pvalue=pvals.z, \n                   zero.pvalue.adj=p.adjust(pvals.z, method=\"BH\"), \n                   DDcategory=cats.all, \n                   Clusters.combined=comps.all.ALL, \n                   Clusters.c1=comps.c1.ALL, \n                   Clusters.c2=comps.c2.ALL)\n  rownames(Genes) <- rownames(SCdat)\n  \n  # place these results objects in the appropriately named assays()\n  # slots of the SummarizedExperiment object\n  metadata(SCdat)[[\"Genes\"]] <- Genes\n  metadata(SCdat)[[\"Zhat.combined\"]] <- MAP\n  metadata(SCdat)[[\"Zhat.c1\"]] <- MAP1\n  metadata(SCdat)[[\"Zhat.c2\"]] <- MAP2\n  \n  # return...\n  return(SCdat)\n}\n\n\n",
    "created" : 1482160047717.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "553173570",
    "id" : "2FBA4612",
    "lastKnownWriteTime" : 1482164146,
    "last_content_update" : 1482164146,
    "path" : "~/Desktop/scDD/R/scDD.R",
    "project_path" : "R/scDD.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}